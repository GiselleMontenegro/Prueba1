---
permalink: /p21/
title: "Random walk"
author_profile: false
sidebar:
  nav: "contentssr"
---

---

Random walk can be defined as the behavior in which a robot moves without aiming a particular trajectory. In most random walk methods, changes in the direction of movement of the robots occur when they interact with other robots or objects in the environment. The selection of a direction of movement can follow deterministic or stochastic rules. In many cases, robots also embed obstacle avoidance behaviors to safely navigate in the environment.

### Objective

The objective of this practical session is to design the control software for a robot swarm in which the individual robots randomly walk in an enclosed environment without colliding with objects, walls or other robots. The swarm, as a whole, must move in the environment evenly---that is, it must cover all the spaces.

### General remarks

The control software of the robots is executed in the form of time steps---that is, the script is executed in the simulator once for each time step. In this experiment, the time step has a length of 100ms. In other words, each of the actions defined in the Lua script will be executed 10 times per second.

Remember that the individual actions of each robot are the ones that lead the robot swarm to achieve the desired behavior.

---

### Exercise 1: Obstacle avoidance in a cluttered scenario

In this exercise, you will design random walk and obstacle avoidance behaviors that allow a swarm of foot-bots to safely navigate in an environment cluttered with obstacles.

**Launching the experiment**

1 - Enter the directory that contains the materials for this practical session.
```
cd ~/swarm_robotics/obstacle_avoidance/
```
2 -  Run the `ARGoS` simulation.
```
argos3 -c obstacle_avoidance_scatter.argos
```

**Experimental setup**

At the beginning of the experiment, a swarm of foot-bots is randomly distributed in a squared bounded arena that contains boxes that obstruct the movement of the robots. During the execution of the experiment, the robots must navigate through the arena avoiding possible collisions with the boxes and with other robots. The experiment will end when the robots can effectively navigate in the arena without colliding.

[![Obstacle avoidance in a cluttered scenario](https://dgarzonramos.github.io/robotics101/assets/images/rwm1.png)](https://youtu.be/bk9Ge-DW4-Y)

**Ballistic motion with in-place rotation**

An easy implementation of random walk is the that follows the principles of ballistic motion: a robot moves straight to the front until it faces an obstacle, when an obstacle is detected, the robot changes its trajectory. This random walk method can embed in-place rotations as an strategy for obstacle avoidance. In other words, when a robot faces an obstacle it simply rotates a random number of time steps, or alternatively, until it stops perceiving the obstacle on its direction of movement.

**Controller description**

The basic control pseudocode is summarized below.

1 - Check if there is an obstacle in front of the robot
```
for each sensor i in proximity sensors at front
do
  if reading[i] == obstacle
  then
    obstacle_in_front = true
  end
end
```

2 - If there is an obstacle in front, perform obstacle avoidance
```
if obstacle_in_front and not rotating
then
  StartRotating(n_timesteps)
end
elseif obstacle in front and n_timesteps != 0
  KeepRotating()
  n_timesteps -= 1
end
else
  StopRotating()
if
```

3 - Set robot velocity
```
if rotating
then
  SetRotationVelocity()
end
else
  SetFordwardVelocity()
end
```

**Proposed solution**

A proposed solution for the exercise will be available to download after midnight.

<!-- [Obstacle avoidance with in-place rotation script](https://dgarzonramos.github.io/robotics/assets/docs/argos/pattern_formation/obstacle_avoidance_rnd.lua) -->

---

### Exercise 2: Obstacle avoidance in an empty scenario

In this exercise, you will test your random walk implementation in a clear environment, and afterwards you will implement a new obstacle avoidance strategy based on repulsion forces.

**Launching the experiment**

1 - Enter the directory that contains the materials for this practical session.
```
cd ~/swarm_robotics/obstacle_avoidance/
```
2 -  Run the `ARGoS` simulation.
```
argos3 -c obstacle_avoidance_empty.argos
```

**Preliminary test**

Test first the control software you developed in Exercise 1. Do the robots show an smooth movement? Do they uniformly cover the whole arena?

**Experimental setup**

At the beginning of the experiment, a swarm of foot-bots is randomly distributed in a squared bounded arena that contains no obstacles. During the execution of the experiment, the robots must navigate the arena avoiding collisions, and in such a way that they uniformly cover space . The experiment will end when the robots can effectively navigate in the arena without colliding.

[![Obstacle avoidance in an empty scenario](https://dgarzonramos.github.io/robotics101/assets/images/rwm2.png)](https://youtu.be/mgojexDZnjs)

**Ballistic motion with repulsion forces**

An more complex, and yet, more effective obstacle avoidance strategy follows the principle of vector fields and repulsion forces. A robot is subject to virtual repulsion forces that are originated by the obstacles that a robot can encounter, and hence, it moves in such a way that avoids colliding with them.

The repulsion force is a unique vector that aggregates the effect of one or many objects around the robot. When a robot perceives a repulsion force, it turns its movement in the opposite direction---i.e., if the vector points to the left, the robot turns to the right and vice versa. The closer the obstacle to the front direction of the robot, the quicker the turn.

**Controller description**

The basic control pseudocode is summarized below. In the context of virtual forces, a _vector_ refers to a quantity possessing both magnitude and direction.
Useful functions to operate with vectors are provided in the section [Lua](lua.md).

1 - Aggregate all proximity readings in a repulsion vector
```
for each sensor i in proximity sensors
do
  Set a 2D vector vec[i] according to {reading_i, angle_i}
  rep_force += vec[i]
end
```

2 - If there is an obstacle close to the robot, perform obstacle avoidance
```
rep_length = GetLength(rep_force)
rep_angle = GetAngle(rep_force)
if rep_length > 0.2
then
  if rep_angle >= 0
  then
    rotate_to_right = true
  end
  else
    rotate_to_left = true
  end
end
else
  rotate_to_right = false
  rotate_to_left = false
end
```

3 - Set robot velocity
```
if rotate_to_right
then
  SetRotateToRightVelocity()
end
elseif rotate_to_left
  SetRotateToLeftVelocity()
end
else
  SetFordwardVelocity()
end
```

**Proposed solution**

A proposed solution for the exercise will be available to download after midnight.

<!-- [Obstacle avoidance with repulsion forces script](https://dgarzonramos.github.io/robotics/assets/docs/argos/pattern_formation/obstacle_avoidance_vec.lua) -->

---

### Further readings

The following readings discuss the influence of random walk behaviors in swarm robotics experiments.

1 - [Kegeleirs, M. et al. (2019). Random Walk Exploration for Swarm Mapping.](https://doi.org/10.1007/978-3-030-25332-5_19)

2 - [Dimidov, C. et al. (2016). Random Walks in Swarm Robotics: An Experiment with Kilobots.](https://doi.org/10.1007/978-3-319-44427-7_16)
